external function Boolean IsEnterprise();external function Boolean HasItemGroups();external function Boolean HasContactClassification();external function Boolean HasItemClassification();external procedure InvListVarieties(record RcVc,record INVc,string,string,string,string,record CostAccBlock,Boolean,var Boolean,                                    var Boolean,var string,var val,var val,var val,var val,roundmode,var val,string,vector val);external procedure HTConsigment(Integer, var string);external procedure FindStockValueAtPosition(string,string,string,var record PISVc);external procedure AddSupersessionsInvList(record RcVc,record INVc,string,record CostAccBlock,roundmode,string,var val,var val,var val);external function roundmode GetCostRoundMode(record RoundBlock);external function roundmode DefaultRoundMode();external procedure GetItemCostPrc(record INVc,record CostAccBlock,record ITVc,Integer,var val);external procedure PrintSerialNumbers_InvVal(record INVc,string,Integer,val,Date,string,Integer); external function val ConsigmentStockQty(string,string,Date);external function val FindCPPriceBackdated(Integer,record INVc,string,val,Date,Boolean);external function Integer ArtCodeCostPricePerLocation(string);external function val FindCostPriceSerialNumberBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer);external function val GetStockQty(string,string,Date,Boolean);external procedure GetCostModel(record INVc,record CostAccBlock,var record ITVc,var Integer,var Integer,Boolean);external function Integer WAPerLocation(record INVc,record ITVc,record CostAccBlock);external function Integer ItemCostPerLocation(record INVc);external function val FindCostPriceLIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);external function val FindCostPriceFIFOBackDated(Integer,record INVc,string,string,val,val,Date,Boolean,Integer,Boolean,Integer,Integer,Integer);external function val FindWAPriceBackdated(Integer,record INVc,string,val,Date,Boolean,Integer);external function Boolean ReadFirstItemInclClosed(string,var record INVc,Boolean,Boolean);external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);external function Boolean FindItemVAR(string,var string,var string,var string,var string);external function val GetStockQty2(string,string,Date,Boolean,Integer);external procedure HTArts(string, string, var string);external procedure HTDepartment(string,var string);external procedure HTArtGroup(string, var string);external procedure HTSupplier(string, var string);external procedure GetItemGroupDescription(string,var string);external procedure CalcSum(val,val,val,val,var val,Integer);external procedure FindStockValue2(record INVc,string,string,Integer,Date,Integer,Boolean,var val,var val,var val,Integer,Integer,Integer,Integer,Boolean,vector val);external procedure HTItemClass(string,var string);external procedure HTCustClassType(string,var string);external function Boolean SetInSet2(string,string);external procedure ItemClassTypef(string,string,var Boolean);external function Boolean FillItemVarArray(string,string,date,var array string,var array val,var Integer,var string,var string,var string,var string);external function val AbsoluteVal(val); //Edit***************************Sasha2,14:05 04.09.2014forward procedure GetIHFileName(record ItemHistVc,var string); //Edit***************************Sasha2,13:47 08.09.2014function integer GetSign(val qty) //Edit***************************Sasha2,15:47 04.09.2014 {begin  integer res;  if (qty<0) then begin  	res = -1;  end else begin  	res = 1;	  end;  GetSign = res;  return;end; //Edit***************************Sasha2,15:47 04.09.2014 }function val Min(val v1,val v2)begin  val res;    if (v1>v2) then begin    res = v2;  end else begin    res = v1;  end;  Min = res;  return;end;//Edit***************************Sasha2,12:45 08.09.2014procedure CollectPUVc(var record IVVc IVr,record ItemHIstVc IHr)begin  Integer i,rwcnt,pos,fi;  record PUVc PUr;  row IVVc IVrw;  Boolean foundf;  string 255 tstr;      foundf = false;  rwcnt = MatRowCnt(IVr);  /*if (IHr.FileName!="PUVc" or (IHr.FileName!="StockMovVc" and IHr.Qty>0)) then begin  	  for (i=0;i<rwcnt;i=i+1) begin	  	MatRowGet(IVr,i,IVrw);	    if (IVrw.ArtCode==IHr.ArtCode and IVrw.OrdRow==IHr.InSerNr) then begin foundf = true; end;	    if (NonBlank(IVrw.SerialNr) and IVrw.SerialNr!=IHr.SerialNr) then begin foundf = false; end;	    if (foundf) then begin	      IVrw.FIFO = IVrw.FIFO + IHr.Qty;	  	  IVrw.PriceFactor = IVrw.PriceFactor + IHr.TotCostPriceCurncy*GetSign(IHr.Qty);	  	  IVrw.Coefficient = IVrw.Coefficient + IHr.TotCostPrice*GetSign(IHr.Qty);	  	  MatRowPut(IVr,i,IVrw);	      i = rwcnt;	    end;	  end;  end else begin*/  	if(IHr.InFileName=="PUVc" and IHr.InSerNr>0)then begin  		  		rwcnt = MatRowCnt(IVr);  		For(i=0;i<rwcnt;i=i+1) begin	  		matrowget(IVr,i,IVrw);	  		if(IVrw.ArtCode==IHr.ArtCode and IVrw.Location==IHr.Location and IVrw.SerialNr==IHr.SerialNr and IVrw.GCNr==IHr.InSerNr and IVrw.Withholdings==IHr.InRow)then begin	  			foundf = true; 	  			fi = i; 	  			goto lEnd;	  		end;			end; lEnd:									if(foundf)then begin				matrowget(IVr,fi,IVrw);				IVrw.Coefficient = IVrw.Coefficient + IHr.TotCostPrice*GetSign(IHr.Qty);				IVrw.PriceFactor = IVrw.PriceFactor + IHr.TotCostPriceCurncy*GetSign(IHr.Qty);				IVrw.FIFO = IVrw.FIFO + IHr.Qty;				matrowput(IVr,i,IVrw);				if(IVrw.FIFO==0 and IVrw.Coefficient==0)then begin					matrowdelete(IVr,fi);					rwcnt = MatRowCnt(IVr);				end;			end else begin				pos = matrowcnt(IVr);				IVrw.OrdRow = IHr.TransNr;				IVrw.CUPNr = IHr.SerNr; //SerNr				IVrw.ArtCode = IHr.ArtCode;				IVrw.GCNr = IHr.InSerNr;				IVrw.Withholdings = IHr.InRow;				PUr.SerNr = IHr.InSerNr;				ReadFirstMain(PUr,1,true);				IVrw.VECode = PUr.VECode;				GetIHFileName(IHr,tstr);				IVrw.Spec = tstr;				IVrw.ServiceDelDate = PUr.TransDate;			  //IVrw.ServiceDelDate = IHr.TransDate;				IVrw.Location = IHr.Location;				IVrw.SerialNr=IHr.SerialNr;				IVrw.CurncyCode = IHr.PUCurncyCode;				IVrw.FIFORowVal = IHr.Qty; //Qty				IVrw.FIFO = IHr.Qty; //RemQty				IVrw.PriceFactor = IHr.TotCostPriceCurncy*GetSign(IHr.Qty); //TotCostPriceCurncy				IVrw.Coefficient = IHr.TotCostPrice*GetSign(IHr.Qty); //TotCostPrice				MatRowPut(IVr,pos,IVrw);			end;  		  	end else begin			foundf = false;			pos = rwcnt;			For(i=0;i<rwcnt;i=i+1) begin	  		matrowget(IVr,i,IVrw);	  		if(IVrw.ArtCode==IHr.ArtCode and IVrw.Location==IHr.Location and IVrw.SerialNr==IHr.SerialNr and IVrw.GCNr==IHr.InSerNr and IVrw.Withholdings==IHr.InRow)then begin	  			foundf = true; 	  			fi = i; 	  			goto lEnd1;	  		end;			end; lEnd1:				if(foundf)then begin				matrowget(IVr,fi,IVrw);				IVrw.Coefficient = IVrw.Coefficient + IHr.TotCostPrice*GetSign(IHr.Qty);				IVrw.PriceFactor = IVrw.PriceFactor + IHr.TotCostPriceCurncy*GetSign(IHr.Qty);				IVrw.FIFO = IVrw.FIFO + IHr.Qty;				matrowput(IVr,i,IVrw);				if(IVrw.FIFO==0 and IVrw.Coefficient==0)then begin					matrowdelete(IVr,fi);					rwcnt = MatRowCnt(IVr);				end;			end else begin								pos = rwcnt;				For(i=0;i<rwcnt;i=i+1) begin					matrowget(IVr,i,IVrw);					if(IVrw.ArtCode==IHr.ArtCode and IVrw.Location==IHr.Location and IVrw.SerialNr==IHr.SerialNr)then begin						foundf = true; 						fi = i; 						goto lEnd2;					end;				end; lEnd2:					if(foundf)then begin					matrowget(IVr,fi,IVrw);					IVrw.Coefficient = IVrw.Coefficient + IHr.TotCostPrice*GetSign(IHr.Qty);					IVrw.PriceFactor = IVrw.PriceFactor + IHr.TotCostPriceCurncy*GetSign(IHr.Qty);					IVrw.FIFO = IVrw.FIFO + IHr.Qty;					matrowput(IVr,i,IVrw);					if(IVrw.FIFO==0 and IVrw.Coefficient==0)then begin						matrowdelete(IVr,fi);						rwcnt = MatRowCnt(IVr);					end;				end else begin					IVrw.OrdRow = IHr.TransNr;					IVrw.CUPNr = IHr.SerNr; //SerNr					IVrw.ArtCode = IHr.ArtCode;					IVrw.GCNr = IHr.InSerNr;					IVrw.Withholdings = IHr.InRow;					PUr.SerNr = IHr.InSerNr;					ReadFirstMain(PUr,1,true);					IVrw.VECode = PUr.VECode;					GetIHFileName(IHr,tstr);					IVrw.Spec = tstr;					IVrw.ServiceDelDate = PUr.TransDate;					//IVrw.ServiceDelDate = IHr.TransDate;					IVrw.Location = IHr.Location;					IVrw.SerialNr=IHr.SerialNr;					IVrw.CurncyCode = IHr.PUCurncyCode;					IVrw.FIFORowVal = IHr.Qty; //Qty					IVrw.FIFO = IHr.Qty; //RemQty					IVrw.PriceFactor = IHr.TotCostPriceCurncy*GetSign(IHr.Qty); //TotCostPriceCurncy					IVrw.Coefficient = IHr.TotCostPrice*GetSign(IHr.Qty); //TotCostPrice					MatRowPut(IVr,MatRowCnt(IVr),IVrw);				end;			end;								/*IVrw.OrdRow = IHr.TransNr;			IVrw.CUPNr = IHr.SerNr; //SerNr			IVrw.ArtCode = IHr.ArtCode;			IVrw.GCNr = IHr.InSerNr;			IVrw.Withholdings = IHr.InRow;			PUr.SerNr = IHr.InSerNr;			ReadFirstMain(PUr,1,true);			IVrw.VECode = PUr.VECode;			GetIHFileName(IHr,tstr);			IVrw.Spec = tstr;			IVrw.ServiceDelDate = PUr.TransDate;			//IVrw.ServiceDelDate = IHr.TransDate;			IVrw.Location = IHr.Location;			IVrw.SerialNr=IHr.SerialNr;			IVrw.CurncyCode = IHr.PUCurncyCode;			IVrw.FIFORowVal = IHr.Qty; //Qty			IVrw.FIFO = IHr.Qty; //RemQty			IVrw.PriceFactor = IHr.TotCostPriceCurncy*GetSign(IHr.Qty); //TotCostPriceCurncy			IVrw.Coefficient = IHr.TotCostPrice*GetSign(IHr.Qty); //TotCostPrice			MatRowPut(IVr,MatRowCnt(IVr),IVrw);*/  	end;  //end;  return;end; //Edit***************************Sasha2,12:45 08.09.2014//Edit***************************Sasha2,11:57 03.09.2014 {procedure PrintIfDateIsBlank(record RcVc RepSpec, record INVc INr,record ItemHistVc IHr,string tstr,integer prlstcnt,array val prices,string basecur) begin  integer i, pos;  record PUVc PUr;      pos = 0; 	StartFormat(15);		OutString(pos,0,INr.Group,false);	    OutString(pos+=20,0,INr.Code,false);	    OutString(pos+=30,0,INr.Name,false);	    OutString(pos+=50,0,INr.Unittext,false);	    PUr.SerNr = IHr.InSerNr;	    ReadFirstMain(PUr,1,true);	    OutString(pos+=30,0,PUr.VECode,false); //Edit***************************Sasha2,11:59 27.01.2015	    OutString(pos+=30,"DblItemHistLine",tstr,false);	    OutDate(pos+=50,0,PUr.TransDate,false);	    //OutDate(pos+=50,0,IHr.TransDate,false);	    OutString(pos+=30,0,IHr.Location,false);	    if (RepSpec.flags[10]==1) then begin	    	OutString(pos+=20,0,IHr.SerialNr,false);	    end;	    //if (blankdate(RepSpec.d1)) then begin  		OutVal(pos+=30,0,IHr.RemQty,M4Qty,false);  		/*end else begin  			OutVal(pos+=30,0,IHr.Qty,M4Qty,false);	  		end;*/	    OutString(pos+=20,0,IHr.PUCurncyCode,false);	    if (basecur!=PUr.CurncyCode) then begin	    	OutString(pos+=25,0,PUr.FrRate /*& " : " & PUr.ToRateB1*/,false);	    end else begin	    	OutString(pos+=25,0,"",false);	    end;	    OutVal(pos+=15,0,AbsoluteVal(IHr.TotCostPriceCurncy/IHr.Qty),M45Val,false);	    //if (blankdate(RepSpec.d1)) then begin		OutVal(pos+=35,0,(IHr.TotCostPriceCurncy/IHr.Qty)*IHr.RemQty,M45Val,false);		/*end else begin			OutVal(pos+=35,0,IHr.TotCostPriceCurncy*GetSign(IHr.Qty),M45Val,false);			end;*/	    OutVal(pos+=30,0,AbsoluteVal(IHr.TotCostPrice/IHr.Qty),M45Val,false);	    //if (blankdate(RepSpec.d1)) then begin		OutVal(pos+=30,0,(IHr.TotCostPrice/IHr.Qty)*IHr.RemQty,M45Val,false);		/*end else begin			OutVal(pos+=30,0,IHr.TotCostPrice*GetSign(IHr.Qty),M45Val,false);			end;*/	    for (i=0;i<prlstcnt;i=i+1) begin	    	OutVal(pos+=30,0,prices[i],M45Val,false);	    end;	EndFormat;    returnend; //Edit***************************Sasha2,11:57 03.09.2014 }//Edit***************************Sasha2,10:48 09.09.2014 {procedure PrintIfDateIsNotBlank(record RcVc RepSpec, record INVc INr,record IVVc IVr,integer prlstcnt,array val prices,string basecur) begin  integer i,j, pos;  record PUVc PUr;  row IVVc IVrw;  integer rwcnt;  	  	rwcnt = MatRowCnt(IVr);	for (j=0;j<rwcnt;j=j+1) begin		MatRowGet(IVr,j,IVrw);		if ((IVrw.FIFO!=0 or IVrw.Coefficient!=0) and nonblank(IVrw.ArtCode)) then begin			pos = 0; 			StartFormat(15);				OutString(pos,0,INr.Group,false);			    OutString(pos+=20,0,INr.Code,false);			    OutString(pos+=30,0,INr.Name,false);			    OutString(pos+=50,0,INr.Unittext,false);			    OutString(pos+=30,0,IVrw.VECode,false); //Edit***************************Sasha2,11:59 27.01.2015			    OutString(pos+=30,"DblItemHistLine",IVrw.Spec,false);			    OutDate(pos+=50,0,IVrw.ServiceDelDate,false);			    OutString(pos+=30,0,IVrw.Location,false);			    if (RepSpec.flags[10]==1) then begin			    	OutString(pos+=20,0,IVrw.SerialNr,false);			    end;				OutVal(pos+=30,0,IVrw.FIFO,M4Qty,false);				    OutString(pos+=20,0,IVrw.CurncyCode,false);			    PUr.SerNr = IVrw.CUPNr;			    ReadFirstMain(PUr,1,true);			    if (basecur!=PUr.CurncyCode) then begin			    	OutString(pos+=25,0,PUr.FrRate /*& " : " & PUr.ToRateB1*/,false);			    end else begin			    	OutString(pos+=25,0,"",false);			    end;			    OutVal(pos+=15,0,IVrw.PriceFactor/IVrw.FIFO,M45Val,false);				OutVal(pos+=35,0,IVrw.PriceFactor,M45Val,false);				    OutVal(pos+=30,0,IVrw.Coefficient/IVrw.FIFO,M45Val,false);				OutVal(pos+=30,0,IVrw.Coefficient,M45Val,false);				    for (i=0;i<prlstcnt;i=i+1) begin			    	OutVal(pos+=30,0,prices[i],M45Val,false);			    end;			EndFormat;		end;  	end;     returnend; //Edit***************************Sasha2,11:57 03.09.2014 }//Edit***************************Sasha2,11:58 03.09.2014 {procedure GetIHFileName(record ItemHistVc IHr,var string tstr)begin		  switch (IHr.FileName) begin	    case "IVVc": tstr = USetStr(1150);	    case "PUVc": tstr = USetStr(1157);      	    case "ProdVc": tstr = USetStr(1162);	    case "RetVc": tstr = USetStr(1421);	    case "StockMovVc": tstr = USetStr(1172);	    case "StockTakeVc": tstr = USetStr(1392);	    case "ProdOperationVc": tstr = USetStr(1633);	    case "SRVc": tstr = USetStr(1636);	    	    case "SHVc": tstr = USetStr(5003);	    case "IVCashVc": tstr = USetStr(11675);	    case "SDVc": tstr = USetStr(5020);	    case "WSVc": tstr = USetStr(7650);	    case "INTransferVc": tstr = USetStr(5040);	  end;	  tstr = tstr & ":";	  tstr = tstr & IHr.TransNr;	  tstr = USetStr(1157) & ":" & IHr.InSerNr;// Edit ************************** Friday, 20 February 2015 18:26:10  return;	  end; //Edit***************************Sasha2,11:58 03.09.2014 }//Edit***************************Sasha2,10:48 09.09.2014 {procedure LoopNewInvVal(record RcVc RepSpec,integer prlstcnt,array string prlists,integer rempos,integer costpos,integer totcostpos)begin  record INVc INr;  record ItemHistVc IHr,IH2r;  record PLVc PLr;  record ItemStatusVc ISr,IS2r;  record PUVc PUr;  boolean TrHs,testf,TrHs1,testf1,print;  string 255 tstr;  array val prices;  integer i,pos,itemqty;  val itemsum,itemcostsum,itemrem,totsum,totrem;  string 20 IHkey;  record IVVc IVr; //Edit***************************Sasha2,13:05 08.09.2014  record BaseCurBlock BCr; //Edit***************************Sasha2,16:21 08.09.2014	record SerBalVc SerBalr;	val qtyBefore;    	BlockLoad(BCr);  	itemsum = 0;  	itemcostsum = 0;  	itemrem = 0;  	totsum = 0;  	totrem = 0;    	if (blankdate(RepSpec.d1)) then begin		IHkey = "ActiveQty";	end else begin		IHkey = "ArtCode";		end;	  	TrHs = true;  	INr.Code = "";	while (LoopMain(INr,1,TrHs)) begin		testf = true;		if (NonBlank(RepSpec.f1) and !SetInSet(INr.Code,RepSpec.f1)) then begin testf = false; end;		if (RepSpec.flags[18]==0 and INr.Terminated<>0) then begin testf = false; end;		if (INr.ItemType!=kItemTypeStocked) then begin testf = false; end;		if (testf) then begin							itemsum = 0;		  	itemcostsum = 0;		  	itemrem = 0;		  	itemqty = 0;		  	if (nonblankdate(RepSpec.d1)) then begin		  		RECORDNEW(IVr);		  	end;		  				for (i=0;i<prlstcnt;i=i+1) begin				PLr.PLCode = prlists[i];				PLr.ArtCode = INr.Code;				if (ReadFirstMain(PLr,2,true)) then begin					prices[i] = PLr.ExVatPrice;				end;			end;						TrHs1 = true;			print = false;			IHr.ArtCode = INr.Code;			while (LoopKey(IHkey,IHr,1,TrHs1)) begin				testf1 = true;				if (IHr.ArtCode!=INr.Code) then begin TrHs1 = false; testf1 = false; end;				if (NonBlank(RepSpec.f2) and !SetInSet(IHr.Location,RepSpec.f2)) then begin testf1 = false; end; 				if (nonblankdate(RepSpec.d1) and RepSpec.d1<IHr.TransDate) then begin testf1 = false; end;				if (IHr.StockAffectf!=1) then begin testf1 = false; end;				if (testf1) then begin					if (blankdate(RepSpec.d1)) then begin						itemrem = itemrem + IHr.RemQty;						totrem = totrem + IHr.RemQty;						itemcostsum = itemcostsum + AbsoluteVal(IHr.TotCostPrice/IHr.Qty);						itemsum = itemsum + (IHr.TotCostPrice/IHr.Qty)*IHr.RemQty;		    		totsum = totsum + (IHr.TotCostPrice/IHr.Qty)*IHr.RemQty;					end else begin						itemrem = itemrem + IHr.Qty;						totrem = totrem + IHr.Qty;						itemcostsum = itemcostsum + AbsoluteVal(IHr.TotCostPrice/IHr.Qty);						itemsum = itemsum + IHr.TotCostPrice*GetSign(IHr.Qty);		    		totsum = totsum + IHr.TotCostPrice*GetSign(IHr.Qty);						end;	    			itemqty = itemqty + 1;	    			print = true;	    			if (RepSpec.ArtMode==1) then begin	    				if (blankdate(RepSpec.d1)) then begin	    					GetIHFileName(IHr,tstr);	    					SerBalr.Item = IHr.ArtCode;							//Edit----------------------Dima  09.09.2015	    					SerBalr.Location = IHr.Location;	    					SerBalr.Serial = IHr.SerialNr;	    					if ((ReadFirstMain(SerBalr,3,true) and (SerBalr.Quant>0)) or INr.SerNrf==0) then begin	    						if (INr.SerNrf!=0) then begin //for backdated stock depreciations	//Edit---Dima  23.03.2016										ISr.Code = INr.Code;										ISr.Location = IHr.Location;										if (ReadFirstMain(ISr,2,true) and ISr.Instock>0) then begin											PrintIfDateIsBlank(RepSpec,INr,IHr,tstr,prlstcnt,prices,BCr.BaseCur1);										end;									end else begin	    							PrintIfDateIsBlank(RepSpec,INr,IHr,tstr,prlstcnt,prices,BCr.BaseCur1);	    						end;		    					end else begin		    						print = false;	    					end;	    				end else begin	    					CollectPUVc(IVr,IHr);	    				end;	    			end;									end;			end; RESETLOOP(IHr);			/*if (blankdate(RepSpec.d1)) then begin		//Edit----------------------Dima  09.09.2015				IS2r.Code = INr.Code;				if (NonBlank(RepSpec.f2)) then begin					IS2r.Location = RepSpec.f2;				end else begin					IS2r.Location = ";;;";					end;				ReadFirstMain(IS2r,2,true);				qtyBefore = itemrem;				itemrem = Min(IS2r.Instock,qtyBefore);				totrem = totrem - qtyBefore + itemrem;				totsum = totsum - itemsum;				itemsum = itemsum * itemrem/qtyBefore;				totsum = totsum + itemsum;			end;	*/					// Edit ************************** Tuesday, 24 May 2016 18:00:45											//Edit--end--------------------Dima  09.09.2015						if (print) then begin				if (RepSpec.ArtMode==0 and (itemrem!=0 or itemsum!=0)) then begin					pos = 0; 					StartFormat(15);					OutString(pos,0,INr.Group,false);	    			OutString(pos+=30,0,INr.Code,false);	    			OutString(pos+=50,0,INr.Name,false);	    			OutString(pos+=120,0,INr.Unittext,false);	    			OutVal(rempos,0,itemrem,M45Val,false);	    			pos = rempos;	    			ISr.Code = INr.Code;	    			if (NonBlank(RepSpec.f2)) then begin	    				ISr.Location = RepSpec.f2;	    			end else begin	    				ISr.Location = ";;;";	    			end;	    			ReadFirstMain(ISr,2,true);	    			OutVal(pos+=30,0,ISr.RsrvQty,M45Val,false);	    			OutVal(costpos,0,itemcostsum/itemqty,M45Val,false);			  		OutVal(totcostpos,0,itemsum,M45Val,false);			  		pos = totcostpos;			  		for (i=0;i<prlstcnt;i=i+1) begin	    				OutVal(pos+=40,0,prices[i],M45Val,false);	    			end;	    			EndFormat;				  	Gray_Divider(0,1);				end;				if (RepSpec.ArtMode==1 and (itemrem!=0 or itemsum!=0)) then begin					if (nonblankdate(RepSpec.d1)) then begin						PrintIfDateIsNotBlank(RepSpec,INr,IVr,prlstcnt,prices,BCr.BaseCur1);					end;					Black_Divider(2,1);					StartFormat(15);					if (RepSpec.Media == mtExcel or RepSpec.Media == mtFile) then begin						OutString(rempos,0,"",false);						OutString(costpos,0,"",false);						OutString(totcostpos,0,"",false);					end else begin						OutVal(rempos,0,itemrem,M45Val,false);						OutVal(costpos,0,itemcostsum/itemqty,M45Val,false);						OutVal(totcostpos,0,itemsum,M45Val,false);						end;				  	EndFormat;				  	Gray_Divider(0,1);									end;			  	print = false;			end;					end;		end;	Black_Divider(2,1);	StartFormat(15);	if (RepSpec.Media == mtExcel or RepSpec.Media == mtFile) then begin		OutString(rempos,0,"",false);		OutString(totcostpos,0,"",false);	end else begin		OutVal(rempos,0,totrem,M45Val,false);		OutVal(totcostpos,0,totsum,M45Val,false);	end;  	EndFormat; 	  return;end; //Edit***************************Sasha2,10:48 09.09.2014 }global  //Edit***************************Sasha2,11:43 02.09.2014 {procedure NewInvValRn(record RcVc RepSpec)begin  record RoundBlock RoundRec;  record CostAccBlock CAb;  record MainStockBlock mst;  val nr,nrq2;  val sum1;  Integer vatflag;  string 255 tstr;  Integer rw;  vector val vlocationtotals;  Boolean found;  record LocationVc Locr;  integer pos,rempos,costpos,totcostpos;  record PLdefVc PLdefr; //Edit***************************Sasha2,13:03 03.09.2014  integer  prlstcnt,i; //Edit***************************Sasha2,13:03 03.09.2014  array string 15 prlists; //Edit***************************Sasha2,13:03 03.09.2014    BlockLoad(mst);  BlockLoad(CAb);  BlockLoad(RoundRec);  vatflag = 0;  StartReportJob(USetStr(2322) & " (modified)");  if (RepSpec.PocketPC == 0) then begin    rw = 1;    if ((nonblank(RepSpec.f1)) or (blank(RepSpec.AccStr))) then begin      HTArts(RepSpec.f1,RepSpec.f1,tstr);      Header(rw,tstr,1);      rw = rw + 1;    end;    if (nonblank(RepSpec.AccStr)) then begin      HTDepartment(RepSpec.AccStr,tstr);      Header(rw,tstr,1);      rw = rw + 1;    end;    if (nonblank(RepSpec.f2)) then begin      tstr = USetStr(2768);      tstr = RepSpec.f2;      Header(rw,tstr,0);    end;    if (HasItemGroups) then begin      HTArtGroup(RepSpec.f3,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;    end;    if (nonblank(RepSpec.FirstAcc)) then begin      tstr = USetStr(2779) & " " & RepSpec.FirstAcc;      Header(rw,tstr,0);    end;    if (HasItemClassification) then begin      HTItemClass(RepSpec.f4,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;     end;    if (HasContactClassification) then begin      HTCustClassType(RepSpec.f5,tstr);      if (nonblank(tstr)) then begin        Header(rw,tstr,1);        rw = rw + 1;      end;     end;    if (nonblank(RepSpec.LastAcc)) then begin      HTSupplier(RepSpec.LastAcc,tstr);      Header(rw,tstr,1);      rw = rw + 1;    end;    if ((ProgramType!=typFirstOffice) and IsBooks==false) then begin      if (RepSpec.flags[1]==0) then begin        tstr = USetStr(2345);       end;        if (RepSpec.flags[1]==1) then begin        tstr = USetStr(2346);            end;        Header(rw,tstr,1);      rw = rw + 1;    end;    if (nonblankdate(RepSpec.d1)) then begin      tstr = RepSpec.d1;      Header(rw,tstr,1);      rw = rw + 1;    end;    if (IsEnterprise) then begin      HTConsigment(RepSpec.flags[12],tstr);      Header(rw,tstr,0);    end;    switch (RepSpec.flags[11]) begin      case 0:         switch (CAb.PrimaryCostModel) begin          case 4:            tstr = USetStr(10554 + CAb.QueuedCostModel);          otherwise            tstr = USetStr(10550 + CAb.PrimaryCostModel);        end;            case 1: tstr = USetStr(10550+RepSpec.flags[11]);      case 2: tstr = USetStr(10550+RepSpec.flags[11]);      case 3: tstr = USetStr(10550+RepSpec.flags[11]);      otherwise /*wierd              switch (CAb.PrimaryCostModel) begin          case 4:            tstr = USetStr(10554 + CAb.QueuedCostModel);          otherwise            tstr = USetStr(10550 + CAb.PrimaryCostModel);        end;*/                tstr = USetStr(10554 + CAb.QueuedCostModel);    end;    Header(rw,USetStr(10549) & ": " & tstr,1);    rw = rw + 1;  end else begin  end;  EndHeader;  if (blank(RepSpec.f5) and (RepSpec.flags[2]==4)) then begin    StartFormat(15);    OutString(140,0,USetStr(20098),false);    EndFormat;      goto LInvValRn;  end;  if (RepSpec.PocketPC== 0) then begin    SetRepCol(2,70);    SetRepColBiDi(3,310,350);    SetRepColBiDi(4,400,440);    SetRepCol(5,240);    SetRepColBiDi(6,480,505);  end else begin    SetRepCol(2,100);    SetRepCol(3,380);    SetRepCol(4,400);    SetRepCol(5,240);  end;    	prlstcnt = 0; //Edit***************************Sasha2,13:09 03.09.2014 {	PLdefr.Code ="";	while (LoopMain(PLdefr,1,true)) begin		if (NonBlank(PLdefr.Code)) then begin			prlists[prlstcnt] = PLdefr.Code;			prlstcnt = prlstcnt + 1;		end;	end; //Edit***************************Sasha2,13:09 03.09.2014 }    if ((RepSpec.ArtMode==0) or (RepSpec.ArtMode==2)) then begin  	pos = 0;  	StartFormat(15);	OutString(pos,0,USetStr(2338),false);    OutString(pos+=30,0,USetStr(2325),false);    OutString(pos+=50,0,USetStr(2326),false);    OutString(pos+=120,0,USetStr(2327),false);    OutStringAdjust(pos+=30,0,USetStr(2330),false,M4Val);    rempos = pos;    OutString(pos+=30,0,USetStr(11540),false); //резерв    OutStringAdjust(pos+=30,0,USetStr(2331),false,M4Val); //Закуп.вар-ть    costpos = pos;    OutStringAdjust(pos+=50,0,USetStr(2332),false,M4Val); //Сума    totcostpos = pos;    for (i=0;i<prlstcnt;i=i+1) begin    	 OutString(pos+=40,0,prlists[i],false);    end;     //OutStringAdjust(pos+=30,0,USetStr(2335),false,M4Val);    EndFormat;    Gray_Divider(0,1);  end;    if (RepSpec.ArtMode==1) then begin  	pos = 0;	  StartFormat(15);	  OutString(pos,0,USetStr(2338),false);    OutString(pos+=20,0,USetStr(2325),false);    OutString(pos+=30,0,USetStr(2326),false);    OutString(pos+=50,0,USetStr(2327),false);    OutString(pos+=30,0,USetStr(4004),false); //Edit***************************Sasha2,11:59 27.01.2015    OutString(pos+=30,0,USetStr(2344),false);    OutString(pos+=50,0,USetStr(2353),false);    OutString(pos+=30,0,USetStr(2569),false);    if (RepSpec.flags[10]==1) then begin    	OutString(pos+=20,0,USetStr(5018),false);    end;    OutStringAdjust(pos+=30,0,USetStr(2330),false,M4Val);    rempos = pos;    OutString(pos+=20,0,USetStr(2514),false);    OutString(pos+=25,0,USetStr(5247),false);    OutString(pos+=15,0,USetStr(2331) & "," & USetStr(2519),false);    OutString(pos+=35,0,USetStr(2332) & "," & USetStr(2519),false);    /*if (RepSpec.flags[11]==1) then begin      OutStringAdjust(pos+=30,0,USetStr(2350),true,M4Val);    end else begin*/      OutStringAdjust(pos+=30,0,USetStr(2331),false,M4Val);      costpos = pos;    //end;    OutStringAdjust(pos+=30,0,USetStr(2332),false,M4Val);    totcostpos = pos;    for (i=0;i<prlstcnt;i=i+1) begin    	 OutString(pos+=30,0,prlists[i],false);    end;     //OutStringAdjust(pos+=30,0,USetStr(2335),false,M4Val);    EndFormat;    Gray_Divider(0,1);  end;  if (RepSpec.ArtMode==3) then begin    StartFormat(15);    OutString(0,0,USetStr(5010),false);    OutStringAdjust(5,0,USetStr(5279),true,M4Val);    EndFormat;  end;		  LoopNewInvVal(RepSpec,prlstcnt,prlists,rempos,costpos,totcostpos);  LInvValRn:;   EndJob;  return;end;  //Edit***************************Sasha2,11:43 02.09.2014 }